//opencv
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/core/core.hpp>
#include <opencv2/video/background_segm.hpp>
#include <opencv2/imgcodecs.hpp>
#include <opencv2/imgproc.hpp>
#include <opencv2/videoio.hpp>
#include <opencv2/highgui.hpp>
#include <opencv2/video.hpp>
//C
#include <stdio.h>
#include <stdlib.h>
#include<time.h>
//C++
#include <iostream>
#include <sstream>
#include <opencv/cv.hpp>
#include <random>

using namespace cv;
using namespace std;

//global variables
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
const double learning_rate = 0.5;
const int kernel_width = 15;
const double tresh = 30;
const double maxval = 255;

//function declarations
void help();

void processVideo();

void help() {
    cout
            << "--------------------------------------------------------------------------" << endl
            << "This program shows how to use background subtraction methods provided by OpenCV." << endl
            << "--------------------------------------------------------------------------" << endl
            << endl;
}

int main(int argc, char *argv[]) {
    help();
    //create Background Subtractor objects
    pMOG2 = createBackgroundSubtractorKNN(); //MOG2 approach
    processVideo();
    destroyAllWindows();
    return EXIT_SUCCESS;
}

void processVideo() {
    VideoCapture camera(0);
    Mat frame;
    Mat ball = imread("ball.jpg");
    int keyboard = 0;
    //read input data. ESC or 'q' for quitting
    while ((char) keyboard != 'q' && (char) keyboard != 27) {
        if (!camera.read(frame)) {
            cerr << "Unable to read next frame of the camera." << endl;
            cerr << "Exiting..." << endl;
            exit(EXIT_FAILURE);
        }
        Mat frame_copy = frame.clone();
        //update the background model
        pMOG2->apply(frame, fgMaskMOG2, learning_rate);
        //Blur the foreground mask to reduce the effect of noise and false positives
        blur(fgMaskMOG2, fgMaskMOG2, Size(kernel_width, kernel_width), Point(-1, -1));
        //Remove the shadow parts and the noise
        threshold(fgMaskMOG2, fgMaskMOG2, tresh, maxval, THRESH_BINARY);
//        Mat t = film_frame(Rect(50, 50, ball.rows, ball.cols));
//        addWeighted(ball, 1, t, 0, 0, ball, -1);
//        ball.copyTo(film_frame(cv::Rect(50, 50, ball.cols, ball.rows)));
        Mat x;
        int flag = 0;
        int pre_x = 10000;
        int pre_y = 50;
        for (int i = -20 + ball.cols; i < pre_x + ball.cols + 20; ++i) {
            if (!(i > 0 && i < frame.cols))
                continue;
            Vec3b color = fgMaskMOG2.at<Vec3b>(Point(i, pre_y + ball.rows / 2));
            if (color[0] >= 240 && color[1] >= 240 && color[2] >= 240) {
                flag = 1;
                int counter = 15;
                while (counter >= 0) {
                    int m_x = rand() % fgMaskMOG2.cols;
                    int m_y = rand() % fgMaskMOG2.rows;
                    Vec3b c = frame.at<Vec3b>(Point(m_x, m_y));
                    counter--;
                    if (m_x >= ball.cols && m_y >= ball.rows && m_y + ball.rows < frame.rows &&
                        m_x + ball.cols < frame.cols) {
//                        cout << frame.rows - m_y - ball.rows << endl;
//                        cout << frame.cols - m_x - ball.cols << endl;
                        x = frame(cv::Rect(m_x, m_y, ball.cols, ball.rows));
                        ball.copyTo(x);
                        pre_x = m_x;
                        pre_y = m_y;
                        break;
                    }
                }
                break;
            }
        }
        if (flag == 0) {
            try {
                x = frame(cv::Rect(pre_x, pre_y, ball.cols, ball.rows));
                ball.copyTo(x);
            } catch (...) {
            }
        }

        imshow("camera", frame);
        imshow("fg", fgMaskMOG2);
        //get the input from the keyboard
        keyboard = waitKey(30);
    }
    camera.release();
}
